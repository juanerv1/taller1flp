#lang eopl

;; ============================================================
;; Taller 1 - Fundamentos de Interpretación y Compilación de LP
;; Integrantes:
;; Juan Esteban Rodriguez Valencia - 2042282
;; Juan Pablo Charry - 2040579
;; Juan Felipe Palechor - 2270963
;; ============================================================

;; ============================================================
;; Ejercicio 1 - invert
;; ------------------------------------------------------------
;; Proposito:
;;   Recibe una lista de pares (x y) y un predicado P.
;;   Retorna una lista con los pares invertidos (y x) 
;;   cuando ambos cumplen el predicado P.
;; Contrato:
;;   (invert L P) -> L'
;; Gramática BNF:
;;   <lista> := ()
;;            | (<par> <lista>)
;;   <par>   := (x y)
;; Pruebas:
;;   > (invert '((3 2) (4 2) (1 5) (2 8)) even?) => ((2 4) (8 2))
;; ============================================================


;invert : Lista × Predicado → Lista
;Recibe una lista L de pares (listas de tamaño 2)
;y un predicado P (función que retorna #t o #f).
;Retorna una lista con los pares invertidos (y x),
;pero SOLO cuando ambos elementos del par cumplen P.


(define invert
  (lambda (L P)
    (if (null? L)
        '()
        (let ((par (car L)))
          (if (and (P (car par)) (P (cadr par)))
              (cons (list (cadr par) (car par))
                    (invert (cdr L) P))
              (invert (cdr L) P))))))

;; Pruebas adicionales:
(invert '((1 3) (2 5) (7 9) (4 6)) odd?) ; => ((3 1) (9 7))
(invert '((5 6) (3 8) (7 2) (9 10)) (lambda (x) (> x 4))) ; => ((6 5) (10 9))
(invert '() even?) ; => ()


;; ============================================================
;; Ejercicio 2 - down
;; ------------------------------------------------------------
;; Proposito: 
;;   Recibe una lista L y retorna una lista con un nivel más 
;;   de paréntesis para cada elemento.
;; Contrato:
;;   (down L) -> L'
;; Pruebas:
;;   > (down '(1 2 3)) => ((1) (2) (3))
;; ============================================================

; down : Lista -> Lista
; Recibe una lista L y retorna una lista donde cada elemento
; de L queda envuelto en un nivel adicional de paréntesis.


(define down
  (lambda (L)
    (if (null? L)
        '()
        (cons (list (car L))     
              (down (cdr L))))))

;; Pruebas adicionales:
(down '(-1 -2 -3)) ; => ((-1) (-2) (-3))
(down '(a 2 "hola")) ; => ((a) (2) ("hola"))
(down '()) ; => ()


;; ============================================================
;; Ejercicio 3 - list-set
;; ------------------------------------------------------------
;; Proposito:
;;   Reemplaza el elemento en la posición n de L por x solo si
;;   cumple con el predicado P.
;; Contrato:
;;   (list-set L n x P) -> L'
;; ============================================================



; list-set : Lista × Número × Elemento × Predicado → Lista
; Reemplaza el elemento en la posición n por x,
; solo si cumple el predicado P. Si no, deja la lista igual.


(define list-set
  (lambda (L n x P)
    (cond
      ;; Caso 1: lista vacía → devolver vacío
      [(null? L) '()]

      ;; Caso 2: ya estoy en la posición n
      [(= n 0)
       (if (P (car L))                ; reviso si cumple el predicado
           (cons x (cdr L))           ; si cumple → pongo x en vez del (car L)
           (cons (car L) (cdr L)))]   ; si no cumple → lo dejo igual

      ;; Caso 3: todavía no llego a la posición
      [else
       (cons (car L) 
             (list-set (cdr L) (- n 1) x P)))])))  ; sigo recorriendo

;; Pruebas adicionales:
(list-set '(1 2 3 4) 2 99 even?) ; => (1 2 3 4)
(list-set '(5 6 7 8) 0 10 odd?)  ; => (10 6 7 8)
(list-set '() 0 1 even?)         ; => ()

;; ============================================================
;; Ejercicio 4 - filter-in


; filter-in : Predicado × Lista → Lista
; Retorna los elementos de L que cumplen el predicado P.

(define filter-in
  (lambda (P L)
    (cond
      [(null? L) '()]                      
      [(P (car L))                         
       (cons (car L) (filter-in P (cdr L)))] 
      [else (filter-in P (cdr L))])))     

;; Pruebas adicionales:
(filter-in odd? '(1 2 3 4 5)) ; => (1 3 5)
(filter-in even? '(10 15 20 25)) ; => (10 20)
(filter-in (lambda (x) (> x 3)) '(1 2 3)) ; => ()

;; ============================================================
;; Ejercicio 5 - list-index

#lang eopl

; list-index : Predicado × Lista → Número | #f
; Recibe:
;   - P : un predicado (función que retorna #t o #f)
;   - L : una lista de elementos

; Retorna:
;   El índice (desde 0) del primer elemento de L que satisface P.
;   Si ningún elemento de L cumple con el predicado, retorna #f.


(define list-index
  (lambda (P L)
    (letrec ((aux
               (lambda (L pos)
                 (cond
                   [(null? L) #f]                   
                   [(P (car L)) pos]                
                   [else (aux (cdr L) (+ pos 1))])))) 
      (aux L 0))))

;; Pruebas adicionales:
(list-index odd? '(2 4 6 7 8)) ; => 3
(list-index even? '(1 3 5 7))   ; => #f
(list-index (lambda (x) (= x 10)) '(5 10 15)) ; => 1

;; ============================================================
;; Ejercicio 6 - swapper
;; ------------------------------------------------------------
;; Contrato:
;;   swapper : S S (Listof Any) -> (Listof Any)
;; Propósito:
;;   Dada una lista L, reemplaza cada ocurrencia de e1 por e2 y cada
;;   ocurrencia de e2 por e1. Otros elementos quedan iguales.
;; Gramática BNF:
;;   <lista> ::= '() | (cons <valor> <lista>)
;; Ejemplos:
;;   (swapper 'a 'd '(a b c d))                 => (d b c a)
;;   (swapper 'a 'd '(a d () c d))              => (d a () c a)
;;   (swapper 'x 'y '(y y x y x y x x y))       => (x x y x y x y y x)

(define (swapper e1 e2 L)
  (if (null? L)
      '()
      (let ([x (car L)])
        (cons (if (equal? x e1)
                  e2
                  (if (equal? x e2) e1 x))
              (swapper e1 e2 (cdr L))))))

;; Pruebas adicionales:
;;(swapper 1 2 '(1 2 3 4 1 2))         => (2 1 3 4 2 1) (Intercambia 1 y 2)
;;(swapper 'a 'b '())                   => () (Caso de lista vacía)
;;(swapper 'hello 'world '(hello world hello))  => (world hello world) (Intercambio de palabras)
;;(swapper 5 10 '(5 10 5 10))           => (10 5 10 5) (Intercambio de números)

;; ============================================================
;; Ejercicio 7 - cartesian-product
;; Contrato:
;;  cartesian-product : (Listof Symbol) (Listof Any) -> (Listof (List Any Any))
;; Propósito:
;;   Dadas L1 y L2, produce el producto cartesiano como lista de pares
;;   (a b) con a∈L1 y b∈L2.
;; Gramática BNF:
;;   <lista-simbolos> ::= '() | (cons <simbolo> <lista-simbolos>)
;;   <par>            ::= (list <a> <b>)
;; Ejemplos:
;;   (cartesian-product '(a b c) '(x y))
;;     => ((a x) (a y) (b x) (b y) (c x) (c y))
;;   (cartesian-product '(p q r) '(5 6 7))
;;     => ((p 5) (p 6) (p 7) (q 5) (q 6) (q 7) (r 5) (r 6) (r 7))

(define (cartesian-product L1 L2)
  ;; Construye pares con a y toda L2, pegando al "tail" sin append.
  (define (pairs-with a l2 tail)
    (if (null? l2)
        tail
        (cons (list a (car l2))
              (pairs-with a (cdr l2) tail))))
  ;; Recorre L1 y encadena resultados de cada a con la recursión del resto.
  (define (outer l1)
    (if (null? l1)
        '()
        (pairs-with (car l1) L2 (outer (cdr l1)))))
  (outer L1))

;; Pruebas adicionales:
;;(cartesian-product '(a) '(1 2 3))      => ((a 1) (a 2) (a 3)) (Solo un elemento en L1)
;;(cartesian-product '() '(x y))         => () (L1 vacío)
;;(cartesian-product '(1 2 3) '())       => () (L2 vacío)
;;(cartesian-product '(p q) '(x y z))    => ((p x) (p y) (p z) (q x) (q y) (q z))

;; ============================================================
;; Ejercicio 8 - mapping
;; ---------------------------------------------------------
;; Contrato:
;;   mapping : (Any -> Number) (Listof Any) (Listof Number) -> (Listof (List Any Number))
;; Propósito:
;;   Dados F, L1 y L2 (de igual tamaño), produce pares (a b) donde
;;   F(a) = b. Se recorre y filtra manualmente.
;; Gramática BNF:
;;   <lista-numeros> ::= '() | (cons <numero> <lista-numeros>)
;;   <par>           ::= (list <a> <b>)
;; Ejemplos:
;;   (mapping (lambda (d) (* d 2)) '(1 2 3) '(2 4 6))
;;     => ((1 2) (2 4) (3 6))
;;   (mapping (lambda (d) (* d 3)) '(1 2 2) '(2 4 6))
;;     => ((2 6))
;;   (mapping (lambda (d) (* d 2)) '(1 2 3) '(3 9 12))
;;     => ()
(define (mapping F L1 L2)
  (if (or (null? L1) (null? L2))
      '()
      (let* ([a (car L1)]
             [b (car L2)]
             [rest (mapping F (cdr L1) (cdr L2))])
        (if (= (F a) b)
            (cons (list a b) rest)
            rest))))

;; Pruebas adicionales:
;;(mapping (lambda (d) (* d 2)) '(1 2 3 4) '(2 4 6 8))   => ((1 2) (2 4) (3 6) (4 8))
;;(mapping (lambda (d) (+ d 1)) '(0 1 2) '(1 2 3))      => ((0 1) (1 2) (2 3))
;;(mapping (lambda (d) (+ d 10)) '(0 1 2) '(10 11 12))  => ((0 10) (1 11) (2 12))
;;(mapping (lambda (d) (* d 3)) '(1 2 2) '(3 5 6))      => ((2 6)) (solo el 2 cumple)

;; ============================================================
;; Ejercicio 9 - inversions
;; ---------------------------------------------------------
;; Contrato:
;;   inversions : (Listof Number) -> Natural
;; Propósito:
;;   Cuenta el número de inversiones en L: pares (i,j) con i<j y a_i > a_j.
;;   Se asume que los números son distintos.
;; Gramática BNF:
;;   <lista-numeros-distintos> ::= '() | (cons <numero> <lista-numeros-distintos>)
;; Ejemplos:
;;   (inversions '(2 3 8 6 1)) => 5
;;   (inversions '(1 2 3 4))   => 0
;;   (inversions '(3 2 1))     => 3
(define (inversions L)
  (define (count-less-than x ls)
    (if (null? ls)
        0
        (+ (if (> x (car ls)) 1 0)
           (count-less-than x (cdr ls)))))
  (if (null? L)
      0
      (+ (count-less-than (car L) (cdr L))
         (inversions (cdr L)))))

;; Pruebas adicionales:
;;(inversions '(5 4 3 2 1))  ;; => 10 (La lista está completamente invertida)
;;(inversions '(1 2 3 4 5))  ;; => 0 (Lista ya ordenada)
;;(inversions '(1 3 2 4 5))  ;; => 1 (solo una inversión entre 3 y 2)
;;(inversions '(6 5 4 3 2 1)) ;; => 15 (todos los elementos invertidos)

;; ============================================================
;; Ejercicio 10 - up
;; ------------------------------------------------------------
;; Proposito:
;;   Recibe una lista L y elimina un nivel de paréntesis en el
;;   nivel más alto. Si un elemento de ese nivel no es lista,
;;   se incluye sin modificarlo.
;;
;; Contrato:
;;   (up L) -> L'
;;
;; Gramática BNF:
;;   <lista>    := ()
;;              := (<elemento> <lista>)

;;   <elemento> := <valor>
;;              := <lista>
;;
;; Se crea la funcion recursiva concat que se encarga de unir 2 listas

(define up
  (lambda (L)
    (letrec
        ([concat
          (lambda (front back)
            (if (null? front)
                back
                (cons (car front) (concat (cdr front) back))))])
    (cond
      [(null? L) '()]
      [(list? (car L))
       (concat (car L) (up (cdr L)))]
      [else
       (cons (car L) (up (cdr L)))]))))

;; Pruebas:
"Pruebas up"
(up '((1 2) (3 4)))               ; ((1 2) (3 4)) => (1 2 3 4)
(up '((x (y)) z))                 ; ((x (y)) z)   => (x (y) z)
(up '((1 2) (3 4) (5 6) (7 8)))   ; ((1 2) (3 4) (5 6) (7 8)))  => (1 2 3 4 5 6 7 8)
(up '((1 2 3 4) (6 (7 8 (9)) 10))); ((1 2 3 4) (6 (7 8 (9)) 10)) => (1 2 3 4 6 (7 8 (9))10)
(up '(1 (2 3)))                   ; (1 (2 3)) => (1 2 3)



;; ============================================================
;; Ejercicio 11 - zip
;; ------------------------------------------------------------
;; Proposito:
;;   Recibe una función binaria F y dos listas L1 y L2 del mismo
;;   tamaño. Retorna una lista donde cada posición n contiene el
;;   resultado de aplicar F al elemento n de L1 y al elemento n
;;   de L2.
;;
;; Contrato:
;;   (zip F L1 L2) -> L'
;;
;; Gramática BNF:
;;   <lista>    := ()
;;              := (<elemento> <lista>)
;;
;;   <elemento> := <valor>
;;

(define zip
  (lambda (f L1 L2)
    (if (null? L1)
        '()
    (cons (f (car L1) (car L2)) (zip f (cdr L1) (cdr L2))))
    ))

;;Pruebas:
"Pruebas zip"
(zip + '(1 4) '(6 2))         ; (7 6)
(zip * '(11 5 6) '(10 9 8))   ; (110 45 48)
(zip / '(4 8) '(2 4))         ; (2 2)
(zip - '(10 20 30) '(2 7 27)) ; (8 13 3)
(zip equal? '(10 20 30) '(12 20 15)) ; '(#f #t #f)


;; ============================================================
;; ============================================================
;; Ejercicio 12 - filter-acum
;; ------------------------------------------------------------
;; Proposito:
;;   Recorre todos los números en el intervalo [a, b] y aplica
;;   la función binaria f acumulativamente sobre aquellos números
;;   que cumplen con el predicado filter. Retorna el valor final
;;   acumulado.
;;
;; Contrato:
;;   (filter-acum a b f acum filter) -> número
;;
;; Gramática BNF:
;;   <intervalo> := a b
;;   <f>         := función binaria (acum x -> nuevo-acum)
;;   <filter>    := función unaria (x -> booleano)
;;


(define filter-acum
  (lambda (a b f acum filter)
    (letrec
        ([cicle
          (lambda (start finish acum)
            (if (> start finish)
                acum
                (if (filter start)
                    (cicle (+ start 1) finish (f acum start))
                    (cicle (+ start 1) finish acum))))])
      (cicle a b acum))))
          
"Pruebas filter-acum"
(filter-acum 1 10 + 0 odd?)    ; 1+3+5+7+9
(filter-acum 1 10 + 0 even?)   ; 2+4+6+8+10
(filter-acum 1 5 * 1 odd?)     ; 1*3*5
(filter-acum 1 8 * 1 even?)    ; 2*4*6*8
(filter-acum 1 30 + 0 odd?)    ; 1+3+5+7+9+11+13+15+17+19+21+23+25+27+29
;; ============================================================
;; Ejercicio 13 - operate
;; ------------------------------------------------------------
;; Proposito:
;;   Recibe una lista de funciones binarias (lrators) de tamaño n y
;;   una lista de números (lrands) de tamaño n+1. Aplica sucesivamente
;;   cada función en lrators sobre los elementos de lrands, en orden,
;;   acumulando el resultado de izquierda a derecha.
;;
;; Contrato:
;;   (operate lrators lrands) -> número
;;
;; Gramática BNF:
;;   <lrators> := ()
;;             := (<operador> <lrators>)
;;
;;   <lrands>  := (<número>)
;;             := (<número> <lrands>)
;;


(define operate
  (lambda (lrators lrands)
    (letrec
        [(cicle
          (lambda (lrators-rest lrands-rest acum)
            (if (null? lrators-rest)
                acum
                (cicle (cdr lrators-rest)
                       (cdr lrands-rest)
                       ((car lrators-rest) acum (car lrands-rest))))))]
      (cicle lrators (cdr lrands)(car lrands)))))

"Pruebas:"
(operate (list + * + - *) '(1 2 8 4 11 6)) ;=> 102
(operate (list *) '(4 5))                  ;=> 20
(operate (list * * * * * *) '(1 2 3 4 5 6 7));=> 5040
(operate (list + - + - + -) '(4 2 6 5 9 2 -2));=> 0
(operate (list + - ) '(4 2 20)); -14

;; ============================================================
;; Ejercicio 14 - path



;< arbol-binario> := ( arbol-vacıo) empty
;                  := (nodo) numero < arbol-binario> < arbol-binario>


; path : Número × <arbol-binario> → Lista-de-símbolos
; Dado un BST, retorna la secuencia de direcciones desde la raíz
; hasta n: 'left o 'right. Si n está en la raíz o el árbol es vacío,
; retorna '() (camino vacío).

(define path
  (lambda (n t)
    (if (null? t)
        '()
        (if (= n (car t))  ; si es igual a n devuelve la lista vacia
               '()
        (if (< n (car t))
            (cons 'left (path n (cadr t)))
            (cons 'right (path n (caddr t))))))))


(define T
  '(14
     (7  () (12 () ()))
     (26 (20 (17 () ()) ())
         ()
         (31 () ()))))

;; Pruebas adicionales:
(path 12 T) ; => (left right)
(path 17 T) ; => (right left left)
(path 14 T) ; => ()
(path 7 '()) ; => () (árbol vacío)
      

;; ============================================================
;; Ejercicio 15 - count-odd-and-even
;; ---------------------------------------------------------
;; Representación de árbol binario:
;;   '()                      ; árbol vacío
;;   (list n left right)      ; nodo con número n y subárboles
;;
;; Contrato:
;;   count-odd-and-even : <arbol-binario> -> (list Natural Natural)
;; Propósito:
;;   Dado un árbol binario con números en sus nodos, retorna (pares impares).
;; Gramática BNF:
;;   <arbol-binario> ::= '()
;;                     |  (list <numero> <arbol-binario> <arbol-binario>)
;; Ejemplo:
;;   (count-odd-and-even
;;     '(14 (7 () (12 () ()))
;;          (26 (20 (17 () ()) ())
;;              (31 () ()))))
;;   => (4 3)
(define (count-odd-and-even arbol)
  (if (null? arbol)
      (list 0 0)
      (let* ([n (car arbol)]
             [L (cadr arbol)]
             [R (caddr arbol)]
             [curr (if (even? n) (list 1 0) (list 0 1))]
             [left (count-odd-and-even L)]
             [right (count-odd-and-even R)])
        (list (+ (car curr) (car left) (car right))
              (+ (cadr curr) (cadr left) (cadr right))))))

;; Pruebas adicionales:
;;(count-odd-and-even
;;  '(1 (2 () ()) (3 () ())))  => (2 1) (2 pares, 1 impar)
;;(count-odd-and-even
;;  '(1 (3 () ()) (5 () ())))  => (0 3) (ningún par)
;;(count-odd-and-even '())      => (0 0) (Árbol vacío)
;;(count-odd-and-even
;;  '(2 (4 () ()) (6 () ())))  => (3 0) (tres pares)


;; ============================================================
;; Ejercicio 16 - simpson-rule
;; ---------------------------------------------------------
;; Contrato:
;;   simpson-rule : (Real -> Real) Real Real (and/c Integer even?) -> Real
;; (Nota: El contrato textual de arriba es conceptual; en código verificamos n par)
;; Propósito:
;;   Aproxima ∫_a^b f(x) dx usando la regla de Simpson con n subintervalos
;;   (n debe ser PAR). 
;; Gramática BNF:
;;   n ∈ 2ℕ, h = (b - a) / n, y_k = f(a + k*h)
;;   S = (h/3) * (y0 + 4y1 + 2y2 + ... + 4y_{n-1} + yn)
;; Ejemplos:
;;   (simpson-rule (lambda (x) (* x (* x x))) 1 5 8)  => 156
;;   (simpson-rule (lambda (x) x) 1 5 12)             => 12
(define (simpson-rule f a b n)
  (if (odd? n)  ;; Si n no es par
      'error    ;; Retorna un valor 'error si n es impar
      (let* ([h (/ (- b a) n)])   ;; Si n es par, continua el cálculo
        (define (yk k) (f (+ a (* k h))))
        (define (peso k)
          (if (or (= k 0) (= k n))
              1
              (if (odd? k) 4 2)))
        (define (sumatoria k)
          (if (> k n)
              0
              (+ (* (peso k) (yk k))
                 (sumatoria (+ k 1)))))
        (* (/ h 3) (sumatoria 0)))))

;; Pruebas adicionales:
;;(simpson-rule (lambda (x) (* x x)) 0 1 4)          => Aproximación de integral de x^2
;;(simpson-rule (lambda (x) 1) 0 10 4)               => 10 (Área de un rectángulo de altura 1)
;;(simpson-rule (lambda (x) (* x (* x x))) 0 5 10)    => Aproximación para x^3 entre 0 y 5
;;(simpson-rule (lambda (x) (+ x 2)) 0 5 2)           => Aproximación para x+2 entre 0 y 5

;; ============================================================
;; Ejercicio 17 - prod-scalar-matriz
;; ------------------------------------------------------------
;; Proposito:
;;   Recibe una matriz mat (lista de listas) y un vector vec (lista),
;;   y retorna una nueva matriz resultante de multiplicar cada fila
;;   de mat por el vector vec, elemento a elemento.
;;
;; Contrato:
;;   (prod-scalar-matriz mat vec) -> matriz
;;
;; Gramática BNF:
;;   <matriz> := ()
;;             | (<fila> <matriz>)
;;
;;   <fila>   := ()
;;             | (<número> <fila>)
;;
;; NOTA:
;; Se hace uso de la funcion zip creada en el Eje. 11


(define prod-scalar-matriz
  (lambda (mat vec)
    (if (null? mat)
        '()
        (cons (zip * (car mat) vec)
              (prod-scalar-matriz (cdr mat) vec)))))

"Pruebas prod-scalar-matriz"

(prod-scalar-matriz '((1 0 0) (0 1 0)(0 0 1)) '(3 5 8)); => ((3 0 0) (0 5 0) (0 0 8))
(prod-scalar-matriz '((1 2 3) (3 2 1)(1 1 1)) '(3 5 8)); => ((3 10 24) (9 10 8) (3 5 8))
(prod-scalar-matriz '((1 1) (2 2) (3 3)) '(2 3)) ;=> ((2 3) (4 6) (6 9))

;; ============================================================
;; Ejercicio 18 - pascal
;; ------------------------------------------------------------
;; Proposito:
;;   Genera la fila N del triángulo de Pascal. La fila 1 es (1).
;;   Cada fila se construye sumando los elementos adyacentes de la
;;   fila anterior, precedidos y seguidos de un 0.
;;
;; Contrato:
;;   (pascal N) -> lista
;;
;; Gramática BNF:
;;   <fila> := (1)
;;          := (<número> <fila>)
;;
;;
;; Nota:
;;  Se hace uso de la funcion zip creada en el Eje. 11
;;  Se crea la funcion recursiva concat que se encarga de unir las listas

(define pascal
  (lambda (N)
    (letrec
        ([concat
          (lambda (front back)
            (if (null? front)
                back
                (cons (car front) (concat (cdr front) back))))]

         [cicle
          (lambda (fila contador)
            (if (< contador N)
                (cicle (zip + (concat '(0) fila)
                               (concat fila '(0)))
                       (+ contador 1))
                fila))])
      (cicle '(1) 1))))

"Pruebas Pascal:"
(pascal 1)
(pascal 2)
(pascal 3)
(pascal 4)
(pascal 5)
(pascal 6)
(pascal 7)
(pascal 8)